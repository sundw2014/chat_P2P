### 计网大作业实验报告
> 孙大伟 2014010782
> https://github.com/sundw2014/net2016_fakeXin

#### 需求分析
##### 基本功能
 1. 上线
 2. 下线
 3. 查询好友状态
 4. 发送消息、文件
 5. 群聊

#### 总体设计
分为几个模块：
登录界面、好友列表界面及状态更新模块、聊天界面、会话线程
其中各界面模块只负责与用户交互，会话线程中实现通信相关的功能，使用QT的事件机制实现这两种模块的连接。
 框图如下：
 ![Alt text](./1483505895197.png)

#### 详细设计
下面介绍每个模块的设计
##### 登录界面
 该界面的功能是与用户交互实现登录，告知服务器上线，并在程序结束时告知服务器下线。
 1. 用户输入用户名、密码、服务器IP和端口号，点击登录，程序建立与服务器的连接，通知上线。
 2. 程序结束时，该模块根据之前的登录信息，告知服务器下线。
##### 好友列表界面及状态更新模块
用户登录成功之后，弹出此窗口。
1. 此模块读取存储在本地的好友列表，显示在窗口中，并在后台定期查询每个好友的状态，更新显示。
2. 用户双击好友之后，如果该好友不在线，弹出提示框；如果在线，则在聊天界面中新建一个tab页。
3. 同时此模块一经建立就会监听自己的服务端口，等待好友的连接，如果有好友接入，则自动在聊天界面中新建一个tab页，类型为一对一会话。
4. 该模块允许用户新建一个群聊会话，点击后，在聊天界面新建一个tab页，类型为群聊会话。
##### 聊天界面
聊天界面由若干个tab页组成，每个tab页中维护一个会话。
tab页分为群聊会话、一对一会话。
###### 群聊会话
新建一个群聊会话之后，发起群聊的用户自动升级为管理员，拥有添加组成员的权力，并在会话中作为中转站，向所有组中成员广播消息。被添加进来的用户作为普通成员无法添加组成员。
1. 点击添加成员之后，弹出一个窗口，用户输入新成员的IP，添加成功之后，群聊模块为新成员创建一个会话线程。
2. 当收到来自某个会话线程的消息时，更新显示，并向所有成员广播该消息（原始发送方也会收到广播，但是发送方会过滤掉由自己发送的消息）。
3. 用户点击发送时，将消息输入框中的消息广播出去，广播的实质是向所有会话线程的消息队列中添加一条待发送消息。
###### 一对一会话
新建一个一对一会话后，发起方和接收方对等，有完全相同的界面。
1. 会话建立之初，建立一个会话线程
2. 收到来自会话线程的消息时，更新显示
3. 用户点发送时，向会话线程的消息队列中添加一条待发送消息
###### 文件发送功能
简单起见，将文件作为一种特殊的消息。
1. 用户点击打开文件选择对话框，选择一个文件
2. 此时消息输入框中是所选文件的路径，用户点击发送
3. 将此特殊消息直接添加到会话线程的消息队列
##### 会话线程
会话线程是真正的工作线程，是程序中最本质的模块。每个会话线程维护一个socket，定期收发消息。会话线程维护自己的收发消息队列。
###### 接口
1. 提供发送消息接口，将输入的消息加入待发送消息队列。
2. 收到消息后发送信号，通知绑定的模块
3. 消息发送成功后发送信号，通知绑定的模块
4. 连接状态变化（如peer掉线，连接中断）后发送信号，通知绑定的模块
###### 事件循环
 事件循环执行的频率由定时器决定，循环体如下：
1. 检测发送队列是否为空，若非空则发送一条消息，发送成功则发出信号通知绑定模块，从队列中去掉成功的消息，否则不做任何操作
2. 查看是否有数据收到，超时未收到数据则继续执行3，若收到数据则从字节流中取出信息，添加到接收消息队列中
3. 检测接收消息队列是否为空，若非空，发送信号通知上层
###### 协议：消息的包装和检出
消息队列中的消息是字符串或文件，需要包装为字节流才能通过tcp发送；同样，收到的数据是字节流，需要从其中检出有效的消息和文件。
1. __包装：__ 
对于普通消息，包装算法如下
```cpp
byteStream = magicHead + msg.toUTF8() + magicTail
```
 其中```magicHead```和```magicTail```作为协议的一部分，是两个预定义的、无意义的字符串。显然这种包装方式理论上会有一定概率出现无法区分消息和magic的情况，但是在这种要求不高的场景下，完全可以忽略这种小概率事件。
 对于文件，包装算法如下
```cpp
byteStream = magicHead + filename.toUTF8() + magicFileSpliter + fileContent + magicFileSpliter + checksum + magicTail
```
 其中```checksum```是对文件内容（即```fileContent```）取MD5
2. __检出__
 因为在包装阶段放弃了理论上的完全可靠，检出变得很简单
 算法如下，输入是字节流：
```cpp
if(byteStream.find(magicHead && magicTail))//查找头和尾
{
	msg = byteStream.mid(magicHead, magicTail)//截出消息体
	if(msg.find(magicFileSpliter))//发现有文件
	{
		if(checksum = md5(fileContent))
			return newFile//校验成功，新文件
		else
			return wrong//校验错误
	}
	return newMsg//新普通消息
}
else//没有有效消息
{
	return nomsg
}
```
#### 结果分析
 1. 测试了一对一的聊天功能，延迟可以接受（不超过一秒），没有遇到丢包和出错的情况，说明上述协议的性能还不错；测试了文件传输的功能，传输小文件（50K）和较大文件（3M），没有遇到校验失败的情况，说明协议性能满足需求。
 1. 测试了三人的群聊功能，可以实现要求的功能，管理员可以发送文件给其他成员。
#### 总结
 1. TCP协议提供了不可靠信道上的可靠数据传输，提供了基于字节流的可靠传输。应用软件可以基于此，设计自己的协议，实现更高层的功能。
 2. 概括地来说，应用层的协议其实是将程序内的数据结构序列化，得到字节流，通过网络传输，接收方通过将字节流反序列化得到程序内的数据结构，从而实现进程之间的数据交换。在这个过程中，必须准确约定序列化的算法，且尽量做到平台无关，需要注意字节序等与平台相关的特性。
 3. 在几乎所有通信方式中，接收方的工作都比发送方要复杂。接收方可以采取轮询、中断等方式实现数据接收。在本次实验中，使用了QT提供的事件循环模型，在保证低延迟的同时没有增加系统开销。
 4. 由于程序分为UI线程和工作线程两部分，UI是不能阻塞的，否则严重影响用户体验；本次实验使用多线程的方法，配合QT的signal-slot模型，将UI线程和工作线程联系起来。
 5. 为了防止阻塞，所有的网络访问都添加了超时处理，有效避免了程序卡死。


#### 测试图集
1. 登录窗口
 ![Alt text](./1483502363078.png)
 登录窗口如上图，默认的用户名是2014010782可以自行更改
 默认的服务器IP和端口号如图
 点击login实现登录，点击exit退出程序
 注：此窗口无法通过只能通过点击exit关闭
2. 登录成功
 ![Alt text](./1483502401697.png)
 登录成功之后弹出如上图两个窗口，好友列表和会话列表窗口
3. 好友列表
 ![Alt text](./1483502473180.png)
 好友列表如上图，稍等片刻之后，所有好友的状态更新完毕，在线好友的ip显示在窗口中。
 双击在线好友即可开始对话。
 点击开始群聊可以开始群聊会话。
 注：好友状态自动更新，更新频率为1Hz，但是实际频率取决于网络状况。
4. 聊天窗口
 ![Alt text](./1483504151147.png)
 上图是一对一聊天界面，收发消息正常，发送文件(30M)正常，右上角显示连接状态
(connected 表示已连接)
点击“选择文件”，打开对话框，选中文件后，直接点击发送即可。收到的文件，在安装目录的```data```文件夹下。
 ![Alt text](./1483504774875.png)
  上图是群聊界面，消息测试正常。
  ![Alt text](./1483504961893.png)
  上图是添加好友对话框，输入需要添加的好友IP即可。
  注：只有群聊发起者有添加好友的权限。


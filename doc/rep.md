### 计网大作业实验报告
> 孙大伟 2014010782
> https://github.com/sundw2014/net2016_fakeXin

#### 需求分析
##### 基本功能
 1. 上线
 2. 下线
 3. 查询好友状态
 4. 发送消息、文件
 5. 群聊

#### 总体设计
分为几个模块：
登录界面、好友列表界面及状态更新模块、聊天界面、会话线程
其中各界面模块只负责与用户交互，会话线程中实现通信相关的功能，使用QT的事件机制实现这两种模块的连接。
 框图如下：
 
#### 详细设计
下面介绍每个模块的设计
##### 登录界面
 该界面的功能是与用户交互实现登录，告知服务器上线，并在程序结束时告知服务器下线。
 1. 用户输入用户名、密码、服务器IP和端口号，点击登录，程序建立与服务器的连接，通知上线。
 2. 程序结束时，该模块根据之前的登录信息，告知服务器下线。
##### 好友列表界面及状态更新界面
用户登录成功之后，弹出此窗口。
1. 此模块读取存储在本地的好友列表，显示在窗口中，并在后台定期查询每个好友的状态，更新显示。
2. 用户双击好友之后，如果该好友不在线，弹出提示框；如果在线，则在聊天界面中新建一个tab页。
3. 同时此模块一经建立就会监听自己的服务端口，等待好友的连接，如果有好友接入，则自动在聊天界面中新建一个tab页，类型为一对一会话。
4. 该模块允许用户新建一个群聊会话，点击后，在聊天界面新建一个tab页，类型为群聊会话。
##### 聊天界面
聊天界面由若干个tab页组成，每个tab页中维护一个会话。
tab页分为群聊会话、一对一会话。
###### 群聊会话
新建一个群聊会话之后，发起群聊的用户自动升级为管理员，拥有添加组成员的权力，并在会话中作为中转站，向所有组中成员广播消息。被添加进来的用户作为普通成员无法添加组成员。
1. 点击添加成员之后，弹出一个窗口，用户输入新成员的IP，添加成功之后，群聊模块为新成员创建一个会话线程。
2. 当收到来自某个会话线程的消息时，更新显示，并向所有成员广播该消息（原始发送方也会收到广播，但是发送方会过滤掉由自己发送的消息）。
3. 用户点击发送时，将消息输入框中的消息广播出去，广播的实质是向所有会话线程的消息队列中添加一条待发送消息。
###### 一对一会话
新建一个一对一会话后，发起方和接收方对等，有完全相同的界面。
1. 会话建立之初，建立一个会话线程
2. 收到来自会话线程的消息时，更新显示
3. 用户点发送时，向会话线程的消息队列中添加一条待发送消息
###### 文件发送功能
简单起见，将文件作为一种特殊的消息。
1. 用户从操作系统的文件管理器拖动一个文件到消息输入框中，并点击发送
2. 此时消息输入框中是所选文件的路径
3. 将此特殊消息直接添加到会话线程的消息队列
##### 会话线程
会话线程是真正的工作线程，是程序中最本质的模块。每个会话线程维护一个socket，定期收发消息。会话线程维护自己的收发消息队列。
###### 接口
1. 提供发送消息接口，将输入的消息加入待发送消息队列。
2. 收到消息后发送信号，通知绑定的模块
3. 消息发送成功之后发送信号，通知绑定的模块
4. 连接状态变化（如peer掉线，连接中断）后发送信号，通知绑定的模块
###### 事件循环
时间循环执行的频率由定时器决定，循环体如下：
1. 检测发送队列是否为空，若非空则发送一条消息，发送成功则发出信号通知绑定模块，从队列中去掉成功的消息，否则不做任何操作
2. 查看是否有数据收到，超时未收到数据则继续执行3，若收到则从字节流中取出信息，添加到接收消息队列中
3. 检测接收到的消息队列是否为空，若非空，发送信号通知上层
###### 协议：消息的包装和检出
消息队列中的消息是字符串或文件，需要转换为字节流才能通过tcp发送；同样，收到的数据是字节流，需要从其中检出有效的消息和文件。
1. __包装：__ 
对于普通消息，包装算法如下
```cpp
byteStream = magicHead + msg.toUTF8() + magicTail
```
 其中```magicHead```和```magicTail```作为协议的一部分，是两个预定义的、无意义的字符串。显然这种包装方式理论上会有一定概率出现无法区分消息和magic的情况，但是在这种要求不高的场景下，完全可以忽略这种小概率事件。
 对于文件，包装算法如下
```cpp
byteStream = magicHead + filename.toUTF8() + magicFileSpliter + fileContent + magicFileSpliter + checksum + magicTail
```
 其中```checksum```是对文件内容（即```fileContent```）取MD5
2. __检出__
 因为在包装阶段放弃了理论上的完全可靠，检出变得很简单
 算法如下，输入是字节流：
```cpp
if(byteStream.find(magicHead && magicTail))//查找头和尾
{
	msg = byteStream.mid(magicHead, magicTail)//截出消息体
	if(msg.find(magicFileSpliter))//有文件，且校验无误
	{
		if(checksum = md5(fileContent))
			return newFile//新文件
		else
			return wrong//校验错误
	}
	return newMsg//新普通消息
}
else//没有有效消息
{
	return nofile
}
```
#### 结果分析

#### 总结

